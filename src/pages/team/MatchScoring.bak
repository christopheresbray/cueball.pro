import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import {
  Container,
  Typography,
  Paper,
  Grid,
  Button,
  Alert,
  AlertTitle,
  CircularProgress,
  Box,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Tooltip,
  Chip,
  Divider,
  useTheme,
  IconButton,
  Badge,
  List,
  ListItem,
  ListItemButton,
  ListItemAvatar,
  ListItemText,
  Avatar,
  ButtonBase,
} from '@mui/material';
import { useAuth } from '../../context/AuthContext';
import {
  getMatch,
  getTeam,
  getTeamByPlayerId,
  getVenue,
  getPlayersForTeam,
  updateMatch,
  getCurrentSeason,
  Match,
  Player,
  Team,
  Venue,
  createDocument,
  Frame,
  getTeams,
} from '../../services/databaseService';
import {
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Help as HelpIcon,
  Refresh as RefreshIcon,
  Edit as EditIcon,
  Info as InfoIcon,
  Clear as ClearIcon,
  PlayArrow as PlayArrowIcon,
} from '@mui/icons-material';
import { format } from 'date-fns';

const MatchScoring: React.FC = () => {
  const { matchId } = useParams<{ matchId: string }>();
  const { user, isAdmin } = useAuth();
  const [match, setMatch] = useState<Match | null>(null);
  const [homeTeam, setHomeTeam] = useState<Team | null>(null);
  const [awayTeam, setAwayTeam] = useState<Team | null>(null);
  const [venue, setVenue] = useState<Venue | null>(null);
  const [homePlayers, setHomePlayers] = useState<Player[]>([]);
  const [awayPlayers, setAwayPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [openFrameDialog, setOpenFrameDialog] = useState(false);
  const [openLineupDialog, setOpenLineupDialog] = useState(false);
  const [editingHomeTeam, setEditingHomeTeam] = useState(true);
  const [selectedPlayers, setSelectedPlayers] = useState<string[]>([]);
  const [currentFrame, setCurrentFrame] = useState<{
    round: number;
    position: number;
    homePlayerId: string;
    awayPlayerId: string;
  } | null>(null);
  const [selectedWinner, setSelectedWinner] = useState<string>('');
  const [activeRound, setActiveRound] = useState<number>(1);
  const [completedRounds, setCompletedRounds] = useState<number[]>([]);
  const [showingSubstitutionDialog, setShowingSubstitutionDialog] = useState<number | null>(null);
  const [isConfirmingRound, setIsConfirmingRound] = useState<number | null>(null);
  const [userTeam, setUserTeam] = useState<Team | null>(null);
  const isUserHomeTeamCaptain = userTeam?.id === match?.homeTeamId;
  const isUserAwayTeamCaptain = userTeam?.id === match?.awayTeamId;
  const [substitutingPosition, setSubstitutingPosition] = useState<number | null>(null);
  const [substitutingHomeTeam, setSubstitutingHomeTeam] = useState(true);
  const [selectedSubstitute, setSelectedSubstitute] = useState<string>('');
  const [editingFrame, setEditingFrame] = useState<{round: number, position: number} | null>(null);

  // Add new state to track lineup history
  const [lineupHistory, setLineupHistory] = useState<{
    [round: number]: {
      homeLineup: string[];
      awayLineup: string[];
    };
  }>({});

  // Add new state for UI enhancements
  const [hoveredFrame, setHoveredFrame] = useState<{round: number, position: number} | null>(null);
  const theme = useTheme();

  // Add new state for the confirmation dialog
  const [showResetConfirmation, setShowResetConfirmation] = useState(false);

  // Fix the handleFrameClick function to avoid blocking all interactions
  const handleFrameClick = (round: number, position: number, event?: React.MouseEvent | React.TouchEvent) => {
    // Don't call preventDefault or stopPropagation here as it blocks other interactions
    if (event) {
      // Only prevent default for this specific element, don't stop propagation
      event.preventDefault();
    }
    
    console.log('Frame clicked:', { round, position });
    
    // Only home team captain can edit frames
    if (!isUserHomeTeamCaptain) {
      console.log('User is not home team captain, returning');
      return;
    }
    
    // If we're already editing this frame, cancel the edit
    if (editingFrame?.round === round && editingFrame?.position === position) {
      console.log('Already editing this frame, canceling edit');
      setEditingFrame(null);
      return;
    }

    // Check if this frame is already scored
    const isScored = isFrameScored(round, position);
    
    if (isScored) {
      // For already scored frames, ask if the user wants to reset the frame
      if (window.confirm('This frame already has a result. Do you want to reset it?')) {
        handleResetFrame(round, position);
      }
      return;
    }
    
    // For unscored frames, check if the round is active
    if (!isRoundActive(round)) {
      // If round isn't active, show a warning
      if (window.confirm('This round is not currently active. Edit it anyway?')) {
        // Proceed with editing
        setEditingFrame({ round, position });
      }
      return;
    }

    // For active rounds with unscored frames, proceed normally
    setEditingFrame({ round, position });
  };

  const calculateMatchScore = () => {
    if (!match?.frameResults) return { home: 0, away: 0 };
    
    return Object.values(match.frameResults).reduce(
      (acc, frame) => {
        if (frame.homeScore) acc.home += frame.homeScore;
        if (frame.awayScore) acc.away += frame.awayScore;
        return acc;
      },
      { home: 0, away: 0 }
    );
  };

  const handleWinnerSelection = (value: string) => {
    setSelectedWinner(value);
  };

  const handleSelectWinner = async (round: number, position: number, winnerId: string) => {
    console.log('handleSelectWinner called:', { round, position, winnerId });
    if (!match?.id) {
      console.log('No match ID found');
      setError('Match ID not found. Please refresh the page.');
      return;
    }

    if (!winnerId) {
      console.log('No winner selected');
      setError('Please select a winner.');
      return;
    }

    try {
      // Set loading state first, before any async operations
      setLoading(true);
      
      // Immediately clear the editing state for better mobile UX
      // This will dismiss the popup right away
      setLoading(true); // Set loading state while processing
      const frameId = `${round}-${position}`;
      console.log('Creating frame with ID:', frameId);
      const existingFrameResults = match.frameResults || {};
      
      // Directly get the player IDs from the match lineup data
      // This addresses the TypeScript error about getPlayerForRound
      let homePlayerId: string;
      let awayPlayerId: string;
      
      // Get the player IDs using the existing match data
      if (match.homeLineup && match.awayLineup) {
        homePlayerId = match.homeLineup[position] || '';
        awayPlayerId = match.awayLineup[position] || '';
      } else {
        homePlayerId = '';
        awayPlayerId = '';
      }
      
      if (!homePlayerId || !awayPlayerId) {
        throw new Error('Missing player information. Please check the lineup.');
      }
      
      console.log('Player IDs:', { homePlayerId, awayPlayerId });

      // Create the frame document with complete data
      const frameData: Frame = {
        matchId: match.id,
        round: round,
        position: position,
        homePlayerId: homePlayerId,
        awayPlayerId: awayPlayerId,
        winnerId: winnerId,
        seasonId: match.seasonId,
        homeScore: winnerId === homePlayerId ? 1 : 0,
        awayScore: winnerId === awayPlayerId ? 1 : 0
      };
      console.log('Frame data to be created:', frameData);

      // Create the frame document in the database
      const frameRef = await createDocument('frames', frameData);
      console.log('Frame document created:', frameRef);
      
      // Prepare data for updating the match
      const updateData: Partial<Match> = {
        frameResults: {
          ...existingFrameResults,
          [frameId]: {
            winnerId: winnerId,
            homeScore: winnerId === homePlayerId ? 1 : 0,
            awayScore: winnerId === awayPlayerId ? 1 : 0,
          },
        },
        // Set match status to in_progress if it was scheduled
        status: match.status === 'scheduled' ? 'in_progress' : match.status
      };
      console.log('Match update data:', updateData);

      // Check if all frames in the round are completed
      const allFramesInRound = Array.from({ length: 4 }, (_, i) => `${round}-${i}`);
      const roundFrames = allFramesInRound.map(id => {
        // Get frame result from the update data or existing match data
        return updateData.frameResults![id] || match.frameResults?.[id];
      });
      const isRoundComplete = roundFrames.every(frame => frame?.winnerId);
      console.log('Round completion check:', { allFramesInRound, roundFrames, isRoundComplete });

      // If round is complete, update the currentRound and roundScored flags
      if (isRoundComplete) {
        updateData.currentRound = round + 1;
        updateData.roundScored = true;
        
        // Check if the entire match is complete (all 16 frames)
        if (round === 3) {
          const allFrames = Array.from({ length: 4 }, (_, r) => 
            Array.from({ length: 4 }, (_, p) => `${r}-${p}`)
          ).flat();
          
          const allFrameResults = allFrames.map(id => 
            updateData.frameResults![id] || match.frameResults?.[id]
          );
          
          const isMatchComplete = allFrameResults.every(frame => frame?.winnerId);
          
          if (isMatchComplete) {
            updateData.status = 'completed';
          }
        }
      }

      // Update the match in the database
      await updateMatch(match.id, updateData);
      console.log('Match updated successfully');
      
      // Update local state
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          frameResults: {
            ...(prevMatch.frameResults || {}),
            ...updateData.frameResults
          },
          currentRound: updateData.currentRound || prevMatch.currentRound,
          roundScored: updateData.roundScored || prevMatch.roundScored,
          status: updateData.status || prevMatch.status
        };
      });

      // Reset UI state
      setEditingFrame(null);
      setSelectedWinner('');
      console.log('Editing frame cleared');
      
      // Show success message
      setError(''); // Clear any previous errors
    } catch (err: any) {
      console.error('Error submitting frame result:', err);
      setError(err.message || 'Failed to submit frame result. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleResetRound = async (roundIndex: number) => {
    if (!match?.id) return;

    try {
      // Find all frames in this round
      const roundFrameIds = Array.from({ length: 4 }, (_, position) => `${roundIndex}-${position}`);
      const existingFrameResults = { ...match.frameResults };
      
      // Remove all frames in this round
      roundFrameIds.forEach(frameId => {
        if (existingFrameResults[frameId]) {
          delete existingFrameResults[frameId];
        }
      });

      const updateData: Partial<Match> = {
        frameResults: existingFrameResults,
        // Reset current round if needed
        ...(match.currentRound && match.currentRound > roundIndex + 1 ? { currentRound: roundIndex + 1 } : {})
      };

      await updateMatch(match.id, updateData);
      
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          frameResults: existingFrameResults,
          ...(prevMatch.currentRound && prevMatch.currentRound > roundIndex + 1 ? { currentRound: roundIndex + 1 } : {})
        };
      });

      // Reset editing state
      setEditingFrame(null);
    } catch (err: any) {
      console.error('Error resetting round:', err);
      setError(err.message || 'Failed to reset round');
    }
  };

  const handleResetFrame = async (round: number, position: number) => {
    if (!match?.id) return;

    try {
      setLoading(true);
      setError('');
      
      const frameId = `${round}-${position}`;
      console.log(`Resetting frame ${frameId}`);
      
      // Make a copy of the existing frame results
      const existingFrameResults = { ...match.frameResults };
      
      // Remove the frame result
      delete existingFrameResults[frameId];

      const updateData: Partial<Match> = {
        frameResults: existingFrameResults
      };

      // Update the match in the database
      await updateMatch(match.id, updateData);
      console.log(`Frame ${frameId} reset successfully`);
      
      // Update local state
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          frameResults: existingFrameResults
        };
      });

      // Make sure any dialogs are closed
      setEditingFrame(null);
      setSelectedWinner('');
    } catch (err: any) {
      console.error('Error resetting frame:', err);
      setError(`Failed to reset frame: ${err.message || 'Unknown error'}`);
      
      // Show an alert to make the error more visible
      alert(`Error resetting frame: ${err.message || 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  const getPlayerName = (playerId: string, isHomeTeam: boolean): string => {
    const players = isHomeTeam ? homePlayers : awayPlayers;
    const player = players.find(p => p.id === playerId);
    return player ? `${player.firstName} ${player.lastName}` : 'Unknown Player';
  };

  const isFrameScored = (round: number, position: number): boolean => {
    if (!match?.frameResults) return false;
    const frameId = `${round}-${position}`;
    return !!match.frameResults[frameId]?.winnerId;
  };

  const getFrameWinner = (round: number, position: number): string | null => {
    if (!match?.frameResults) return null;
    const frameId = `${round}-${position}`;
    return match.frameResults[frameId]?.winnerId || null;
  };

  // Helper function to check if all frames in a round are scored
  const isRoundComplete = (roundIndex: number) => {
    return Array.from({ length: 4 }).every((_, position) => 
      isFrameScored(roundIndex, position)
    );
  };

  // Helper function to check if a round is active
  const isRoundActive = (roundIndex: number) => {
    return roundIndex + 1 === activeRound;
  };

  // Helper function to check if a round can be played
  const isRoundPlayable = (roundIndex: number) => {
    if (roundIndex + 1 === 1) return true; // First round is always playable
    return completedRounds.includes(roundIndex); // Previous round must be completed
  };

  // Handle round confirmation
  const handleRoundConfirmation = (roundIndex: number) => {
    setCompletedRounds([...completedRounds, roundIndex]);
    setActiveRound(roundIndex + 2); // Move to next round
    setShowingSubstitutionDialog(roundIndex + 1); // Show substitution dialog for next round
  };

  const handleResetMatch = async () => {
    if (!match?.id || !isUserHomeTeamCaptain) return;

    try {
      setLoading(true);
      // Get the original lineups from the first round
      const originalHomeLineup = match.homeLineup?.filter((_, i) => i < 4) || [];
      const originalAwayLineup = match.awayLineup?.filter((_, i) => i < 4) || [];

      // Update match to clear frame results and reset round state
      const updateData: Partial<Match> = {
        frameResults: {},
        currentRound: 1,
        roundScored: false,
        status: 'in_progress',
        homeLineup: originalHomeLineup,
        awayLineup: originalAwayLineup
      };

      await updateMatch(match.id, updateData);
      
      // Update local state
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          ...updateData
        };
      });
      setActiveRound(1);
      setCompletedRounds([]);
      setShowingSubstitutionDialog(null);
      // Clear lineup history
      setLineupHistory({});
      setError('');
      
      // Close the confirmation dialog
      setShowResetConfirmation(false);
    } catch (err: any) {
      console.error('Error resetting match:', err);
      setError(err.message || 'Failed to reset match');
    } finally {
      setLoading(false);
    }
  };

  const handleOpenLineupDialog = (isHomeTeam: boolean) => {
    // Only allow lineup editing if match is still in scheduled status
    if (match?.status !== 'scheduled') {
      setError('Lineup can only be edited before the match has started.');
      return;
    }
    
    setEditingHomeTeam(isHomeTeam);
    setSelectedPlayers(isHomeTeam ? match?.homeLineup || [] : match?.awayLineup || []);
    setOpenLineupDialog(true);
  };

  const handleCloseLineupDialog = () => {
    setOpenLineupDialog(false);
    setSelectedPlayers([]);
  };

  const handlePlayerSelection = (playerId: string) => {
    setSelectedPlayers(prev => {
      const newSelection = [...prev];
      const index = newSelection.indexOf(playerId);
      if (index === -1) {
        newSelection.push(playerId);
      } else {
        newSelection.splice(index, 1);
      }
      return newSelection;
    });
  };

  const handleSaveLineup = async () => {
    if (!match?.id) return;

    try {
      const updateData: Partial<Match> = {
        [editingHomeTeam ? 'homeLineup' : 'awayLineup']: selectedPlayers
      };

      await updateMatch(match.id, updateData);
      
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          ...updateData
        };
      });

      handleCloseLineupDialog();
    } catch (err: any) {
      console.error('Error updating lineup:', err);
      setError(err.message || 'Failed to update lineup');
    }
  };

  const handleSubstitution = async (position: number, isHomeTeam: boolean) => {
    setSubstitutingPosition(position);
    setSubstitutingHomeTeam(isHomeTeam);
    setSelectedSubstitute('');
  };

  // Add helper function to get substitutes for a specific round
  const getSubstitutesForRound = (round: number, isHomeTeam: boolean): string[] => {
    // Get all players from the initial lineup
    const allPlayers = isHomeTeam ? match?.homeLineup || [] : match?.awayLineup || [];
    
    // Get the current active players for this round
    const activePlayers = Array.from({ length: 4 }, (_, i) => 
      getPlayerForRound(round, i, isHomeTeam)
    );
    
    // Return players who are not currently active
    return allPlayers.filter(playerId => !activePlayers.includes(playerId));
  };

  // Modify getPlayerForRound to ensure past frames show original players
  const getPlayerForRound = (round: number, position: number, isHomeTeam: boolean): string => {
    // For frames that have already been played, we need to return the players who actually played them
    if (match?.frameResults) {
      const frameId = `${round-1}-${position}`;
      const frameResult = match.frameResults[frameId];
      
      if (frameResult) {
        // This frame has been played
        // We need to get the players from our lineup history
        // Since frameResults don't store the actual player IDs directly
        const homePlayer = getHomePreviousRoundPlayer(round-1, position);
        const awayPlayer = getAwayPreviousRoundPlayer(round-1, position);
        return isHomeTeam ? homePlayer : awayPlayer;
      }
    }
    
    // For current and future rounds
    
    // For round 1, use the initial lineup
    if (round === 1) {
      if (isHomeTeam) {
        return match?.homeLineup?.[position] || '';
      } else {
        return match?.awayLineup?.[position] || '';
      }
    }

    // For other rounds, check the lineup history
    if (lineupHistory[round]) {
      if (isHomeTeam) {
        return lineupHistory[round].homeLineup[position];
      } else {
        // Apply the rotation pattern for away team
        const rotatedPosition = getOpponentPosition(round, position, false);
        return lineupHistory[round].awayLineup[rotatedPosition];
      }
    }

    // If we don't have a recorded lineup for this round,
    // look for the most recent recorded lineup before this round
    for (let r = round - 1; r >= 1; r--) {
      if (lineupHistory[r]) {
        if (isHomeTeam) {
          return lineupHistory[r].homeLineup[position];
        } else {
          // Apply the rotation pattern for away team
          const rotatedPosition = getOpponentPosition(round, position, false);
          return lineupHistory[r].awayLineup[rotatedPosition];
        }
      }
    }

    // If no history is found, fall back to the initial lineup
    if (isHomeTeam) {
      return match?.homeLineup?.[position] || '';
    } else {
      // Apply the rotation pattern for away team
      const rotatedPosition = getOpponentPosition(round, position, false);
      return match?.awayLineup?.[rotatedPosition] || '';
    }
  };

  // Helper functions to get the actual players that played in previous rounds
  const getHomePreviousRoundPlayer = (round: number, position: number): string => {
    if (!match) return '';
    
    // If this is a later round, check lineup history first
    if (round > 0 && lineupHistory[round]) {
      return lineupHistory[round].homeLineup[position];
    }
    
    // Otherwise, use the initial lineup
    return match.homeLineup?.[position] || '';
  };
  
  const getAwayPreviousRoundPlayer = (round: number, position: number): string => {
    if (!match) return '';
    
    // If this is a later round, check lineup history first
    if (round > 0 && lineupHistory[round]) {
      return lineupHistory[round].awayLineup[position];
    }
    
    // Otherwise, use the initial lineup
    return match.awayLineup?.[position] || '';
  };

  // Modify handleConfirmSubstitution to properly track substitutes
  const handleConfirmSubstitution = async (position: number, isHomeTeam: boolean, playerId: string) => {
    if (!match?.id || !playerId) return;

    try {
      const nextRound = activeRound;
      
      // Get the current lineup for this round
      let currentHomeLineup = [...(match.homeLineup || [])];
      let currentAwayLineup = [...(match.awayLineup || [])];
      
      // If we have history for the current round, use that instead
      if (lineupHistory[nextRound]) {
        currentHomeLineup = [...lineupHistory[nextRound].homeLineup];
        currentAwayLineup = [...lineupHistory[nextRound].awayLineup];
      } else {
        // If this is the first substitution for this round, 
        // we need to copy the previous round's lineup or the initial lineup
        for (let r = nextRound - 1; r >= 1; r--) {
          if (lineupHistory[r]) {
            currentHomeLineup = [...lineupHistory[r].homeLineup];
            currentAwayLineup = [...lineupHistory[r].awayLineup];
            break;
          }
        }
      }
      
      // Store the original lineups before substitution
      const originalHomePlayers = [...currentHomeLineup];
      const originalAwayPlayers = [...currentAwayLineup];
      
      // Update the appropriate lineup
      if (isHomeTeam) {
        // Store the player being replaced but keep them in the overall lineup
        const replacedPlayer = currentHomeLineup[position];
        currentHomeLineup[position] = playerId;
        
        // Make sure the substituted player isn't lost from the overall lineup
        if (replacedPlayer && !currentHomeLineup.includes(replacedPlayer)) {
          // The player has been completely removed, so we need to add them back
          // Add them to the end of the array if they're not already in it
          if (match.homeLineup && !match.homeLineup.includes(replacedPlayer)) {
            const updatedHomeLineup = [...match.homeLineup, replacedPlayer];
            // Update the match data
            await updateMatch(match.id, { homeLineup: updatedHomeLineup });
            // Update local state
            setMatch(prevMatch => {
              if (!prevMatch) return null;
              return {
                ...prevMatch,
                homeLineup: updatedHomeLineup
              };
            });
          }
        }
      } else {
        // Store the player being replaced but keep them in the overall lineup
        const replacedPlayer = currentAwayLineup[position];
        currentAwayLineup[position] = playerId;
        
        // Make sure the substituted player isn't lost from the overall lineup
        if (replacedPlayer && !currentAwayLineup.includes(replacedPlayer)) {
          // The player has been completely removed, so we need to add them back
          // Add them to the end of the array if they're not already in it
          if (match.awayLineup && !match.awayLineup.includes(replacedPlayer)) {
            const updatedAwayLineup = [...match.awayLineup, replacedPlayer];
            // Update the match data
            await updateMatch(match.id, { awayLineup: updatedAwayLineup });
            // Update local state
            setMatch(prevMatch => {
              if (!prevMatch) return null;
              return {
                ...prevMatch,
                awayLineup: updatedAwayLineup
              };
            });
          }
        }
      }

      // Record the lineup for this round in history
      setLineupHistory(prev => ({
        ...prev,
        [nextRound]: {
          homeLineup: currentHomeLineup,
          awayLineup: currentAwayLineup
        }
      }));

      // We don't need to update the main lineup array in the match document
      // as we're now tracking substitutions in the lineupHistory state

    } catch (err: any) {
      console.error('Error making substitution:', err);
      setError(err.message || 'Failed to make substitution');
    }
  };

  // Add helper function to determine who plays against whom in each round
  const getOpponentPosition = (round: number, position: number, isHome: boolean): number => {
    if (isHome) {
      // Home team positions (1-4) stay fixed, playing A,B,C,D in sequence
      return position;
    } else {
      // Away team positions rotate each round
      // Round 1: A,B,C,D plays against 1,2,3,4
      // Round 2: B,C,D,A plays against 1,2,3,4
      // Round 3: C,D,A,B plays against 1,2,3,4
      // Round 4: D,A,B,C plays against 1,2,3,4
      return (position + (round - 1)) % 4;
    }
  };

  // Add helper function to determine who breaks in each frame
  const isHomeTeamBreaking = (round: number, position: number): boolean => {
    // Home team breaks in odd-numbered frames (0-based index)
    const frameNumber = (round - 1) * 4 + position;
    return frameNumber % 2 === 0;
  };

  // Enhanced UI helper functions
  const getFrameStatus = (round: number, position: number) => {
    const isScored = isFrameScored(round, position);
    const isActive = isRoundActive(round);
    const isEditing = editingFrame?.round === round && editingFrame?.position === position;
    
    if (isScored) return 'completed';
    if (isEditing) return 'editing';
    if (isActive) return 'active';
    return 'pending';
  };
  
  const getFrameStatusColor = (status: string) => {
    switch (status) {
      case 'completed': return theme.palette.success.main;
      case 'editing': return theme.palette.primary.main;
      case 'active': return theme.palette.info.main;
      default: return theme.palette.text.disabled;
    }
  };
  
  const getFrameTooltip = (round: number, position: number) => {
    const homePlayerName = getPlayerName(getPlayerForRound(round + 1, position, true), true);
    const awayPlayerName = getPlayerName(getPlayerForRound(round + 1, position, false), false);
    const isScored = isFrameScored(round, position);
    const isActive = isRoundActive(round);
    const breaksFirst = isHomeTeamBreaking(round, position) ? homePlayerName : awayPlayerName;
    
    // Base information about the frame
    let info = `${homePlayerName} vs ${awayPlayerName}\nBreak: ${breaksFirst}`;
    
    // Status information
    if (isScored) {
      const winnerId = getFrameWinner(round, position);
      const winnerName = winnerId === getPlayerForRound(round + 1, position, true) ? homePlayerName : awayPlayerName;
      info += `\nWinner: ${winnerName}`;
      
      // Actions for home team captain
      if (isUserHomeTeamCaptain) {
        info += '\n(Click to reset frame result)';
      }
    } else if (isActive) {
      // For active, unscored frames
      if (isUserHomeTeamCaptain) {
        info += '\nClick to score this frame';
      } else {
        info += '\nWaiting for home team to score';
      }
    } else {
      // For inactive, unscored frames
      if (isUserHomeTeamCaptain) {
        info += '\nNot yet active (click to score out of sequence)';
      } else {
        info += '\nNot yet available';
      }
    }
    
    return info;
  };

  // Add a function to start the match
  const handleStartMatch = async () => {
    if (!match?.id || !isUserHomeTeamCaptain) return;
    
    // Verify both teams have valid lineups
    if (!match?.homeLineup || match.homeLineup.length < 4 || !match?.awayLineup || match.awayLineup.length < 4) {
      setError('Both teams must set their lineup before starting the match.');
      return;
    }
    
    try {
      setLoading(true);
      
      // Update match status to in_progress
      const updateData: Partial<Match> = {
        status: 'in_progress',
        currentRound: 1
      };
      
      await updateMatch(match.id, updateData);
      
      // Update local state
      setMatch(prevMatch => {
        if (!prevMatch) return null;
        return {
          ...prevMatch,
          status: 'in_progress',
          currentRound: 1
        };
      });
      
      setError(''); // Clear any errors
    } catch (err: any) {
      console.error('Error starting match:', err);
      setError(err.message || 'Failed to start match');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    const fetchMatchData = async () => {
      if (!matchId || !user) return;

      try {
        setLoading(true);
        setError('');

        // Get match data first
        const matchData = await getMatch(matchId);
        if (!matchData) {
          setError('Match not found');
          return;
        }

        // Load the home and away teams
        const [homeTeamData, awayTeamData, venueData] = await Promise.all([
          getTeam(matchData.homeTeamId),
          getTeam(matchData.awayTeamId),
          matchData.venueId ? getVenue(matchData.venueId) : null,
        ]);

        // Find which team the user is captain of
        let userTeamData = null;
        if (homeTeamData && homeTeamData.captainUserId === user.uid) {
          userTeamData = homeTeamData;
        } else if (awayTeamData && awayTeamData.captainUserId === user.uid) {
          userTeamData = awayTeamData;
        }

        // If not found directly, try team_players
        if (!userTeamData) {
          const teamByPlayer = await getTeamByPlayerId(user.uid);
          if (teamByPlayer && (teamByPlayer.id === matchData.homeTeamId || teamByPlayer.id === matchData.awayTeamId)) {
            userTeamData = teamByPlayer.id === matchData.homeTeamId ? homeTeamData : awayTeamData;
          }
        }

        // Set the user's team
        setUserTeam(userTeamData);

        // If user is not a captain of either team and not an admin, restrict access
        if (!userTeamData && !isAdmin) {
          setError('You are not authorized to view this match');
          return;
        }

        const currentSeason = await getCurrentSeason();
        if (!currentSeason) {
          setError('No active season found');
          return;
        }

        const [homePlayersData, awayPlayersData] = await Promise.all([
          getPlayersForTeam(matchData.homeTeamId, currentSeason.id!),
          getPlayersForTeam(matchData.awayTeamId, currentSeason.id!),
        ]);

        setMatch(matchData);
        setHomeTeam(homeTeamData);
        setAwayTeam(awayTeamData);
        setVenue(venueData);
        setHomePlayers(homePlayersData);
        setAwayPlayers(awayPlayersData);
      } catch (err: any) {
        setError(err.message || 'Failed to load match data');
      } finally {
        setLoading(false);
      }
    };

    fetchMatchData();
  }, [matchId, user, isAdmin]);

  // Add a separate button handler function at the component level
  const handleResetButtonClick = (round: number, position: number, e: React.MouseEvent) => {
    // Use stopPropagation but not preventDefault to ensure button works on mobile
    e.stopPropagation();
    
    if (window.confirm('Are you sure you want to reset this frame result?')) {
      handleResetFrame(round, position);
    }
  };

  if (loading) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, textAlign: 'center' }}>
        <CircularProgress />
      </Container>
    );
  }

  if (!match || !homeTeam || !awayTeam) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4 }}>
        <Alert severity="error">{error}</Alert>
      </Container>
    );
  }

  const matchScore = calculateMatchScore();

  return (
    <Container maxWidth="lg" sx={{ mt: 4 }}>
      {loading && !match ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
          <CircularProgress />
        </Box>
      ) : error ? (
        <Alert severity="error" sx={{ mb: 4 }}>
          {error}
        </Alert>
      ) : (
        <>
          {/* Match Summary Card */}
          <Paper elevation={3} sx={{ p: 3, mb: 4 }}>
            <Grid container spacing={2}>
              {/* Match Status */}
              <Grid item xs={12}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h5" component="h1">
                    {match?.status === 'scheduled' ? 'Match Setup' : 
                     match?.status === 'in_progress' ? 'Match Scoring' : 'Match Summary'}
                  </Typography>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Chip 
                      label={match?.status === 'completed' ? 'Completed' : match?.status === 'in_progress' ? 'In Progress' : 'Scheduled'} 
                      color={match?.status === 'completed' ? 'success' : match?.status === 'in_progress' ? 'primary' : 'default'}
                    />
                    {isUserHomeTeamCaptain && match?.status !== 'scheduled' && (
                      <Tooltip title="Reset all match results">
                        <Button
                          variant="outlined"
                          color="error"
                          size="small"
                          onClick={() => setShowResetConfirmation(true)}
                          sx={{ ml: 1 }}
                        >
                          Reset Match
                        </Button>
                      </Tooltip>
                    )}
                  </Box>
                </Box>
                <Divider sx={{ mb: 2 }} />
              </Grid>
              
              {/* Team Names and Score */}
              <Grid item xs={12} sm={8}>
            <Box sx={{ 
              display: 'flex',
                  alignItems: 'center', 
              justifyContent: 'space-between',
                  px: { xs: 1, sm: 3 },
                  py: 2
            }}>
              {/* Home Team */}
              <Box sx={{ 
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                    flex: 1
              }}>
                <Typography 
                  variant="h6" 
                  component="div"
                  sx={{ 
                    fontWeight: 'bold',
                        textAlign: 'center',
                        color: isUserHomeTeamCaptain ? 'primary.main' : 'text.primary',
                        mb: 1
                      }}
                    >
                      {homeTeam?.name || 'Home Team'}
                      {isUserHomeTeamCaptain && (
                        <Chip 
                          label="Your Team" 
                          color="primary" 
                          size="small" 
                          sx={{ ml: 1, height: 20, fontSize: '0.625rem' }} 
                        />
                      )}
                </Typography>
                    
                    <Typography variant="h3" component="div" sx={{ fontWeight: 'bold' }}>
                  {matchScore.home}
                </Typography>
              </Box>

                  {/* VS */}
                  <Box sx={{ mx: 2, display: { xs: 'none', sm: 'block' } }}>
                    <Typography variant="h6" color="text.secondary">vs</Typography>
              </Box>

              {/* Away Team */}
              <Box sx={{ 
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                    flex: 1
              }}>
                <Typography 
                  variant="h6" 
                  component="div"
                  sx={{ 
                    fontWeight: 'bold',
                        textAlign: 'center',
                        color: isUserAwayTeamCaptain ? 'secondary.main' : 'text.primary',
                        mb: 1
                      }}
                    >
                      {awayTeam?.name || 'Away Team'}
                      {isUserAwayTeamCaptain && (
                        <Chip 
                          label="Your Team" 
                          color="secondary" 
                          size="small" 
                          sx={{ ml: 1, height: 20, fontSize: '0.625rem' }} 
                        />
                      )}
                </Typography>
                    
                    <Typography variant="h3" component="div" sx={{ fontWeight: 'bold' }}>
                  {matchScore.away}
                </Typography>
              </Box>
            </Box>
              </Grid>
              
              {/* Match Details */}
              <Grid item xs={12} sm={4}>
                <Box sx={{ 
                  p: 2, 
                  bgcolor: 'background.default', 
                  borderRadius: 1,
                  height: '100%',
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center'
                }}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    Venue: 
                    <Typography component="span" variant="body2" sx={{ ml: 1 }}>
                      {venue?.name || 'TBD'}
                    </Typography>
                  </Typography>
                  
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    Date: 
                    <Typography component="span" variant="body2" sx={{ ml: 1 }}>
                      {match?.scheduledDate ? format(match.scheduledDate.toDate(), 'MMMM dd, yyyy') : 'TBD'}
                    </Typography>
                  </Typography>
                  
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    Current Round:
                    <Typography component="span" variant="body2" sx={{ ml: 1, fontWeight: 'bold' }}>
                      {match?.currentRound || 1}
                    </Typography>
                  </Typography>
                  
                  {match?.status === 'completed' && (
                    <Typography variant="subtitle2" color="success.main" sx={{ fontWeight: 'bold', mt: 1 }}>
                      Match Complete - Final Score: {matchScore.home} - {matchScore.away}
                    </Typography>
                  )}
                </Box>
              </Grid>
            </Grid>
            
            {/* Quick Controls */}
            {match?.status === 'scheduled' ? (
              <Box sx={{ mt: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Button
                  variant="outlined"
                  color="primary"
                  disabled={!isUserHomeTeamCaptain}
                  onClick={() => handleOpenLineupDialog(true)}
                  startIcon={<EditIcon />}
                >
                  {match?.homeLineup && match.homeLineup.length >= 4 ? 'Edit Home Lineup' : 'Set Home Lineup'}
                </Button>
                
                <Typography variant="body2" color="text.secondary">
                  Both teams must set lineups before the match can start
                </Typography>
                
                <Button
                  variant="outlined"
                  color="secondary"
                  disabled={!isUserAwayTeamCaptain}
                  onClick={() => handleOpenLineupDialog(false)}
                  startIcon={<EditIcon />}
                >
                  {match?.awayLineup && match.awayLineup.length >= 4 ? 'Edit Away Lineup' : 'Set Away Lineup'}
                </Button>
              </Box>
            ) : (
              match?.status === 'completed' && (
                <Box sx={{ mt: 3, p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
                  <Typography variant="body2" color="text.secondary" align="center">
                    Match is completed. All scores have been recorded.
                  </Typography>
                </Box>
              )
            )}
          </Paper>
          
          {/* Status Alert - Only show for scheduled matches */}
          {match?.status === 'scheduled' && (
            <Alert 
              severity="warning" 
              variant="outlined"
              sx={{ mb: 4 }}
              action={
                isUserHomeTeamCaptain && (
                  <Button 
                    color="inherit" 
                    size="small"
                    disabled={!match?.homeLineup || !match?.awayLineup || 
                             match.homeLineup?.length < 4 || match.awayLineup?.length < 4}
                    onClick={handleStartMatch}
                  >
                    Start Match
                  </Button>
                )
              }
            >
              <AlertTitle>Match Not Started</AlertTitle>
              {isUserHomeTeamCaptain ? (
                <>
                  As the home team captain, you need to:
                  <ol style={{ margin: '8px 0', paddingLeft: '20px' }}>
                    <li>Ensure both teams have set their lineups (4 players each)</li>
                    <li>Click "Start Match" when both teams are ready</li>
                  </ol>
                </>
              ) : isUserAwayTeamCaptain ? (
                <>
                  Please set your lineup. The home team captain will start the match when both teams are ready.
                </>
              ) : (
                <>
                  This match has not started yet. Both teams need to set their lineups before the match can begin.
                </>
              )}
            </Alert>
          )}
          
          {/* Instructions Panel */}
          <Paper elevation={1} sx={{ 
            p: 2, 
            mb: 4, 
            bgcolor: match?.status === 'scheduled' 
              ? 'warning.light' 
              : match?.status === 'in_progress' 
                ? 'info.light' 
                : 'success.light'
          }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              {match?.status === 'scheduled' ? (
                <InfoIcon color="warning" />
              ) : match?.status === 'in_progress' ? (
                <InfoIcon color="info" />
              ) : (
                <CheckCircleIcon color="success" />
              )}
              
              <Typography variant="body2">
                {match?.status === 'scheduled' ? (
                  isUserHomeTeamCaptain ? 
                    'As the home team captain, you need to set your lineup and start the match when both teams are ready.' :
                  isUserAwayTeamCaptain ?
                    'As the away team captain, you need to set your lineup. The home team captain will start the match.' :
                    'Waiting for both teams to set their lineups and for the home team captain to start the match.'
                ) : match?.status === 'in_progress' ? (
                  isUserHomeTeamCaptain ? 
                    'As the home team captain, click on a frame in the current round to record the winner.' : 
                    'The home team captain will record frame results. You can view the progress here.'
                ) : (
                  'This match is completed. All frame results have been recorded.'
                )}
              </Typography>
            </Box>
          </Paper>
          
          {/* Rest of the UI components */}
          <Typography variant="h6" gutterBottom>
            Match Frames
          </Typography>
          
          {Array.from({ length: 4 }).map((_, roundIndex) => (
            <Box key={`round-${roundIndex}`} sx={{ mb: 4 }}>
              <Paper elevation={1} sx={{ p: 2, mb: 2, bgcolor: isRoundActive(roundIndex) ? 'rgba(144, 202, 249, 0.08)' : 'inherit' }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" component="h2">
                    Round {roundIndex + 1}
                    {isRoundComplete(roundIndex) && (
                      <Chip 
                        size="small" 
                        label="Completed" 
                        color="success" 
                        sx={{ ml: 2 }} 
                        icon={<CheckCircleIcon />} 
                      />
                    )}
                    {activeRound === roundIndex + 1 && (
                      <Chip 
                        size="small" 
                        label="Current" 
                        color="primary" 
                        sx={{ ml: 2 }} 
                      />
                    )}
                  </Typography>
                  
                  {isRoundComplete(roundIndex) && isUserHomeTeamCaptain && (
                    <Box>
                      <Tooltip title="Reset round results">
                        <IconButton 
                          size="small"
                          color="warning"
                          onClick={() => window.confirm('Are you sure you want to reset this round?') && 
                            handleResetRound(roundIndex)}
                        >
                          <RefreshIcon />
                        </IconButton>
                      </Tooltip>
                    </Box>
                  )}
                </Box>
                
                <Grid container spacing={2}>
                {Array.from({ length: 4 }).map((_, position) => {
                  const frameId = `${roundIndex}-${position}`;
                  const homePlayerId = getPlayerForRound(roundIndex + 1, position, true);
                  const awayPlayerId = getPlayerForRound(roundIndex + 1, position, false);
                    const homePlayerName = getPlayerName(homePlayerId, true);
                    const awayPlayerName = getPlayerName(awayPlayerId, false);
                    const isScored = isFrameScored(roundIndex, position);
                    const isActive = isRoundActive(roundIndex);
                    const winnerId = getFrameWinner(roundIndex, position);
                    const homeWon = winnerId === homePlayerId;
                    const awayWon = winnerId === awayPlayerId;
                    const isEditing = editingFrame?.round === roundIndex && editingFrame?.position === position;
                    const isBreaking = isHomeTeamBreaking(roundIndex, position);
                    const frameStatus = getFrameStatus(roundIndex, position);

                  return (
                      <Grid item xs={12} sm={6} md={3} key={frameId}>
                        <Tooltip 
                          title={getFrameTooltip(roundIndex, position)} 
                          placement="top"
                          arrow
                        >
                      <Paper
                            onClick={(event) => handleFrameClick(roundIndex, position, event)}
                            onTouchStart={(event) => handleFrameClick(roundIndex, position, event)}
                            onMouseEnter={() => setHoveredFrame({round: roundIndex, position})}
                            onMouseLeave={() => setHoveredFrame(null)}
                        sx={{
                              p: 2,
                              position: 'relative',
                              borderLeft: '4px solid',
                              borderColor: getFrameStatusColor(frameStatus),
                              // Show pointer cursor for all frames when user is home team captain
                              cursor: isUserHomeTeamCaptain ? 'pointer' : 'default',
                              transition: 'all 0.2s ease',
                          '&:hover': {
                                // Apply hover effects to all frames for home team captain
                                boxShadow: isUserHomeTeamCaptain ? 4 : 2,
                                transform: isUserHomeTeamCaptain ? 'translateY(-2px)' : 'none',
                              },
                              // Add styles for active state on mobile (no hover on touch devices)
                              ...(isUserHomeTeamCaptain && {
                                '&:active': {
                                  boxShadow: 4,
                                  transform: 'translateY(-2px)',
                                }
                              }),
                              opacity: isActive || isScored ? 1 : 0.7,
                            }}
                          >
                            <Typography variant="subtitle2" gutterBottom color="text.secondary">
                              Frame {position + 1}
                              {isBreaking ? (
                                <Chip size="small" label="Home breaks" color="primary" variant="outlined" sx={{ml: 1, fontSize: '0.6rem'}} />
                              ) : (
                                <Chip size="small" label="Away breaks" color="secondary" variant="outlined" sx={{ml: 1, fontSize: '0.6rem'}} />
                              )}
                            </Typography>
                            
                            <Divider sx={{ my: 1 }} />
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                              <Box sx={{ 
                                display: 'flex',
                                alignItems: 'center',
                                gap: 0.5,
                                p: 1,
                                borderRadius: 1,
                                ...(homeWon && { 
                                  bgcolor: 'success.light', 
                                  color: 'white',
                                  fontWeight: 'bold',
                                  boxShadow: 1
                                })
                              }}>
                                {homeWon && <CheckCircleIcon fontSize="small" />}
                                <Typography 
                                  variant="body2" 
                                  component="span"
                                  sx={{ 
                                    fontWeight: homeWon ? 'bold' : 'normal'
                                  }}
                                >
                                  {homePlayerName || 'TBD'}
                                </Typography>
                              </Box>
                              
                              <Box sx={{ 
                                display: 'flex',
                                alignItems: 'center',
                                gap: 0.5,
                                p: 1,
                                borderRadius: 1,
                                ...(awayWon && { 
                                  bgcolor: 'success.light', 
                                  color: 'white',
                                  fontWeight: 'bold',
                                  boxShadow: 1 
                                })
                              }}>
                                <Typography 
                                  variant="body2" 
                                  component="span"
                                  sx={{ 
                                    fontWeight: awayWon ? 'bold' : 'normal'
                                  }}
                                >
                                  {awayPlayerName || 'TBD'}
                                </Typography>
                                {awayWon && <CheckCircleIcon fontSize="small" />}
                              </Box>
                            </Box>
                            
                            {/* Frame status indicator */}
                            {isScored ? (
                              <Box sx={{ 
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                mt: 1
                              }}>
                                <Box sx={{ 
                                  bgcolor: 'success.light', 
                                  color: 'white', 
                                  textAlign: 'center',
                                  borderRadius: 1,
                                  py: 0.5,
                                  px: 1,
                                  fontSize: '0.75rem',
                                  flex: 1
                                }}>
                                  Completed
                                </Box>
                                {isUserHomeTeamCaptain && (
                                  <Tooltip title="Reset frame result">
                                    <IconButton 
                                      size="small" 
                                      color="error"
                                      onClick={(e) => handleResetButtonClick(roundIndex, position, e)}
                                      sx={{ ml: 0.5 }}
                                    >
                                      <RefreshIcon fontSize="small" />
                                    </IconButton>
                                  </Tooltip>
                                )}
                              </Box>
                            ) : isActive ? (
                              <Box sx={{ 
                                bgcolor: isUserHomeTeamCaptain ? 'primary.light' : 'text.disabled', 
                                color: 'white', 
                                textAlign: 'center',
                                borderRadius: 1,
                                py: 0.5,
                                mt: 1,
                                fontSize: '0.75rem'
                              }}>
                                {isUserHomeTeamCaptain ? 'Click to Score' : 'Waiting for score'}
                              </Box>
                            ) : (
                              <Box sx={{ 
                                bgcolor: 'text.disabled', 
                                color: 'white', 
                                textAlign: 'center',
                                borderRadius: 1,
                                py: 0.5,
                                mt: 1,
                                fontSize: '0.75rem'
                              }}>
                                Pending
                              </Box>
                            )}
                      </Paper>
                        </Tooltip>
                    </Grid>
                  );
                })}
              </Grid>

                {isRoundComplete(roundIndex) && roundIndex + 1 < 4 && !isConfirmingRound && (
                  <Box sx={{ textAlign: 'center', mt: 3 }}>
                    <Button
                      variant="contained"
                      color="primary"
                      onClick={() => handleRoundConfirmation(roundIndex)}
                      startIcon={<CheckCircleIcon />}
                    >
                      Confirm Round {roundIndex + 1} & Set Lineup for Next Round
                    </Button>
                    <Typography variant="caption" display="block" sx={{ mt: 1, color: 'text.secondary' }}>
                      You'll be able to make substitutions before the next round begins
                    </Typography>
                  </Box>
                )}
              </Paper>
            </Box>
          ))}
        </>
      )}

        {/* Lineup Edit Dialog */}
        <Dialog
          open={openLineupDialog}
          onClose={handleCloseLineupDialog}
          fullWidth
          maxWidth="md"
          aria-labelledby="lineup-dialog-title"
        >
          <DialogTitle id="lineup-dialog-title" sx={{ bgcolor: editingHomeTeam ? 'primary.light' : 'secondary.light', color: 'white' }}>
            {editingHomeTeam ? 'Edit Home Team Lineup' : 'Edit Away Team Lineup'}
          </DialogTitle>
          
          <DialogContent dividers>
            <Alert severity="info" sx={{ mb: 2 }}>
              <AlertTitle>Important</AlertTitle>
              <Typography variant="body2">
                • You must select exactly 4 players for your lineup before the match can start.<br />
                • Once the match starts, lineups cannot be changed.<br />
                • Player positions determine matchups for each round.
              </Typography>
            </Alert>
            
            <Typography variant="body2" color="text.secondary" paragraph>
              Select 4 players for the {editingHomeTeam ? 'home' : 'away'} team lineup. 
              {editingHomeTeam 
                ? ' Home positions remain fixed throughout the match.' 
                : ' Away positions rotate each round according to the rotation pattern.'}
            </Typography>
            
            <Grid container spacing={3} sx={{ mt: 1 }}>
              <Grid item xs={12} md={6}>
                <Paper elevation={2} sx={{ p: 2, height: '100%', bgcolor: 'background.default' }}>
                  <Typography variant="subtitle1" gutterBottom>
                    Available Players
                  </Typography>
                  <Divider sx={{ mb: 2 }} />
                  
                  <List dense sx={{ maxHeight: 300, overflow: 'auto', bgcolor: 'background.paper' }}>
                    {(editingHomeTeam ? homePlayers : awayPlayers)
                      .filter(player => !selectedPlayers.includes(player.id!))
                      .map((player) => (
                        <ListItem key={player.id} disablePadding>
                          <ListItemButton 
                            onClick={() => handlePlayerSelection(player.id!)}
                    sx={{
                              py: 1,
                              '&:hover': {
                                bgcolor: 'action.hover',
                              }
                            }}
                          >
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: editingHomeTeam ? 'primary.main' : 'secondary.main' }}>
                                {player.firstName.charAt(0)}{player.lastName.charAt(0)}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText 
                              primary={`${player.firstName} ${player.lastName}`} 
                            />
                          </ListItemButton>
                        </ListItem>
                    ))}
                    {(editingHomeTeam ? homePlayers : awayPlayers).filter(player => !selectedPlayers.includes(player.id!)).length === 0 && (
                      <ListItem>
                        <ListItemText 
                          primary="No more available players" 
                          sx={{ color: 'text.secondary', fontStyle: 'italic' }} 
                        />
                      </ListItem>
                    )}
                  </List>
                </Paper>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <Paper elevation={2} sx={{ p: 2, height: '100%', bgcolor: editingHomeTeam ? 'primary.light' : 'secondary.light', color: '#fff' }}>
                  <Typography variant="subtitle1" gutterBottom>
                    Selected Players ({selectedPlayers.length}/4)
                  </Typography>
                  <Divider sx={{ mb: 2, borderColor: 'rgba(255,255,255,0.2)' }} />
                  
                  <List sx={{ bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 1 }}>
                    {Array.from({ length: 4 }).map((_, index) => {
                      const playerId = selectedPlayers[index];
                      const player = playerId ? 
                        (editingHomeTeam ? homePlayers : awayPlayers).find(p => p.id === playerId) : 
                        null;
                      
                      return (
                        <ListItem 
                          key={index}
                          secondaryAction={
                            player && (
                              <IconButton 
                                edge="end" 
                                onClick={() => {
                                  setSelectedPlayers(prev => prev.filter(id => id !== playerId));
                                }}
                                sx={{ color: 'inherit' }}
                              >
                                <ClearIcon />
                              </IconButton>
                            )
                          }
                        >
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: player ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)' }}>
                              {player ? `${index + 1}` : '?'}
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText 
                            primary={player ? `${player.firstName} ${player.lastName}` : `Player ${index + 1} (click to select)`} 
                            secondary={editingHomeTeam ? `Plays position ${index + 1}` : `Plays position ${String.fromCharCode(65 + index)}`}
                            secondaryTypographyProps={{ color: 'inherit', sx: { opacity: 0.7 } }}
                          />
                        </ListItem>
                      );
                    })}
                  </List>
                  
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="caption" sx={{ opacity: 0.7 }}>
                      {editingHomeTeam ? 
                        'Home team positions (1,2,3,4) stay fixed each round.' : 
                        'Away team positions (A,B,C,D) rotate each round according to the rotation pattern.'}
                    </Typography>
                  </Box>
                </Paper>
              </Grid>
            </Grid>
          </DialogContent>
        
        <DialogActions sx={{ px: 3, py: 2 }}>
          <Button onClick={handleCloseLineupDialog} color="inherit">
            Cancel
          </Button>
            <Button
              onClick={handleSaveLineup}
              variant="contained"
            color={editingHomeTeam ? 'primary' : 'secondary'}
            disabled={selectedPlayers.length !== 4}
            >
              Save Lineup
            </Button>
          </DialogActions>
        </Dialog>

        {/* Winner selection dialog - using Material UI's Dialog component */}
        <Dialog
          open={!!editingFrame}
          onClose={() => setEditingFrame(null)}
          aria-labelledby="winner-dialog-title"
          maxWidth="xs"
          fullWidth
        >
          <DialogTitle id="winner-dialog-title" sx={{ textAlign: 'center' }}>
            Select Winner
          </DialogTitle>
          
          <DialogContent>
            {editingFrame && (
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, pt: 1 }}>
                {(() => {
                  const homePlayerId = getPlayerForRound(editingFrame.round + 1, editingFrame.position, true);
                  const awayPlayerId = getPlayerForRound(editingFrame.round + 1, editingFrame.position, false);
                  const homePlayerName = getPlayerName(homePlayerId, true);
                  const awayPlayerName = getPlayerName(awayPlayerId, false);
                  
                  return (
                    <>
                      <Button
                        variant={selectedWinner === homePlayerId ? "contained" : "outlined"}
                        color="primary"
                        size="large"
                        onClick={() => handleWinnerSelection(homePlayerId)}
                        fullWidth
                        sx={{ py: 1.5 }}
                      >
                        {homePlayerName || 'Home Player'}
                      </Button>
                      
                      <Button
                        variant={selectedWinner === awayPlayerId ? "contained" : "outlined"}
                        color="secondary"
                        size="large"
                        onClick={() => handleWinnerSelection(awayPlayerId)}
                        fullWidth
                        sx={{ py: 1.5 }}
                      >
                        {awayPlayerName || 'Away Player'}
                      </Button>
                    </>
                  );
                })()}
              </Box>
            )}
          </DialogContent>
          
          <DialogActions sx={{ px: 3, pb: 3 }}>
            <Button
              variant="outlined"
              color="error"
              onClick={() => setEditingFrame(null)}
              sx={{ mr: 1 }}
              disabled={loading}
            >
              Cancel
            </Button>
            
            <Button
              variant="contained"
              color="success"
              onClick={() => editingFrame && handleSelectWinner(
                editingFrame.round, 
                editingFrame.position, 
                selectedWinner
              )}
              disabled={!selectedWinner || loading}
              startIcon={loading ? <CircularProgress size={20} color="inherit" /> : null}
            >
              {loading ? 'Saving...' : 'Confirm'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Substitution Dialog */}
        <Dialog
          open={showingSubstitutionDialog !== null}
          onClose={() => setShowingSubstitutionDialog(null)}
          aria-labelledby="substitution-dialog-title"
          maxWidth="md"
          fullWidth
        >
          <DialogTitle id="substitution-dialog-title" sx={{ bgcolor: 'info.main', color: 'white' }}>
            Player Substitutions - Round {showingSubstitutionDialog !== null ? showingSubstitutionDialog + 1 : ''}
          </DialogTitle>
          <DialogContent dividers>
            <Alert severity="info" sx={{ mb: 2 }}>
              <AlertTitle>Player Rotation Rules</AlertTitle>
              <Typography variant="body2">
                • <strong>Home team positions:</strong> Stay fixed (1, 2, 3, 4)<br />
                • <strong>Away team positions:</strong> Rotate each round according to this pattern:<br />
                &nbsp;&nbsp;&nbsp;&nbsp; Round 1: A, B, C, D play against 1, 2, 3, 4<br />
                &nbsp;&nbsp;&nbsp;&nbsp; Round 2: B, C, D, A play against 1, 2, 3, 4<br />
                &nbsp;&nbsp;&nbsp;&nbsp; Round 3: C, D, A, B play against 1, 2, 3, 4<br />
                &nbsp;&nbsp;&nbsp;&nbsp; Round 4: D, A, B, C play against 1, 2, 3, 4
              </Typography>
            </Alert>
            
            <Grid container spacing={2}>
              {/* Home Team Lineup */}
              <Grid item xs={12} sm={6}>
                <Paper elevation={2} sx={{ p: 2, bgcolor: 'primary.light', color: 'white' }}>
                  <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
                    {homeTeam?.name} Lineup
                    {isUserHomeTeamCaptain && <Chip size="small" label="Your Team" color="default" sx={{ ml: 1 }} />}
                  </Typography>
                  
                  <Box sx={{ mb: 2, p: 1, bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 1 }}>
                    <Typography variant="caption">
                      Home players keep the same positions each round
                    </Typography>
                  </Box>
                  
                  {Array.from({ length: 4 }).map((_, position) => {
                    const upcomingRound = (showingSubstitutionDialog || 0) + 1;
                    const playerId = getPlayerForRound(upcomingRound, position, true);
                    return (
                      <Box key={position} sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        mb: 1, 
                        p: 1, 
                        bgcolor: 'rgba(255,255,255,0.15)', 
                        borderRadius: 1,
                        alignItems: 'center'
                      }}>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <Avatar sx={{ bgcolor: 'primary.dark', mr: 1 }}>
                            {position + 1}
                          </Avatar>
                          <Typography>
                            {getPlayerName(playerId, true)}
                          </Typography>
                        </Box>
                        {isUserHomeTeamCaptain && (
                          <Button 
                            size="small" 
                            variant="contained" 
                            color="inherit"
                            onClick={() => handleSubstitution(position, true)}
                            disabled={getSubstitutesForRound(upcomingRound, true).length === 0}
                          >
                            Substitute
                          </Button>
                        )}
                      </Box>
                    );
                  })}
                  
                  {/* Home team substitutes */}
                  {isUserHomeTeamCaptain && showingSubstitutionDialog !== null && (
                    <Box sx={{ mt: 2, p: 1, bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        Available Substitutes
                      </Typography>
                      {getSubstitutesForRound((showingSubstitutionDialog || 0) + 1, true).length > 0 ? (
                        getSubstitutesForRound((showingSubstitutionDialog || 0) + 1, true).map(playerId => (
                          <Chip 
                            key={playerId}
                            label={getPlayerName(playerId, true)}
                            size="small"
                            sx={{ m: 0.5, bgcolor: 'rgba(255,255,255,0.2)' }}
                          />
                        ))
                      ) : (
                        <Typography variant="caption" sx={{ fontStyle: 'italic' }}>
                          No substitutes available
                        </Typography>
                      )}
                    </Box>
                  )}
                </Paper>
              </Grid>
              
              {/* Away Team Lineup */}
              <Grid item xs={12} sm={6}>
                <Paper elevation={2} sx={{ p: 2, bgcolor: 'secondary.light', color: 'white' }}>
                  <Typography variant="subtitle1" fontWeight="bold" gutterBottom>
                    {awayTeam?.name} Lineup
                    {isUserAwayTeamCaptain && <Chip size="small" label="Your Team" color="default" sx={{ ml: 1 }} />}
                  </Typography>
                  
                  <Box sx={{ mb: 2, p: 1, bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 1 }}>
                    <Typography variant="caption">
                      Away positions rotate each round
                    </Typography>
                  </Box>
                  
                  {Array.from({ length: 4 }).map((_, position) => {
                    const upcomingRound = (showingSubstitutionDialog || 0) + 1;
                    const playerId = getPlayerForRound(upcomingRound, position, false);
                    const awayPosition = String.fromCharCode(65 + getOpponentPosition(upcomingRound, position, false));
                    const playsAgainst = position + 1;
                    return (
                      <Box key={position} sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        mb: 1, 
                        p: 1, 
                        bgcolor: 'rgba(255,255,255,0.15)', 
                        borderRadius: 1,
                        alignItems: 'center'
                      }}>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <Avatar sx={{ bgcolor: 'secondary.dark', mr: 1 }}>
                            {awayPosition}
                          </Avatar>
                          <Typography>
                            {getPlayerName(playerId, false)}
                            <Typography variant="caption" display="block">
                              Plays against position {playsAgainst}
                            </Typography>
                          </Typography>
                        </Box>
                        {isUserAwayTeamCaptain && (
                          <Button 
                            size="small" 
                            variant="contained" 
                            color="inherit"
                            onClick={() => handleSubstitution(position, false)}
                            disabled={getSubstitutesForRound(upcomingRound, false).length === 0}
                          >
                            Substitute
                          </Button>
                        )}
                      </Box>
                    );
                  })}
                  
                  {/* Away team substitutes */}
                  {isUserAwayTeamCaptain && showingSubstitutionDialog !== null && (
                    <Box sx={{ mt: 2, p: 1, bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        Available Substitutes
                      </Typography>
                      {getSubstitutesForRound((showingSubstitutionDialog || 0) + 1, false).length > 0 ? (
                        getSubstitutesForRound((showingSubstitutionDialog || 0) + 1, false).map(playerId => (
                          <Chip 
                            key={playerId}
                            label={getPlayerName(playerId, false)}
                            size="small"
                            sx={{ m: 0.5, bgcolor: 'rgba(255,255,255,0.2)' }}
                          />
                        ))
                      ) : (
                        <Typography variant="caption" sx={{ fontStyle: 'italic' }}>
                          No substitutes available
                        </Typography>
                      )}
                    </Box>
                  )}
                </Paper>
              </Grid>
            </Grid>
            
            {/* Substitution selection - only shown when a position is being substituted */}
            {substitutingPosition !== null && (
              <Paper sx={{ mt: 2, p: 2, bgcolor: substitutingHomeTeam ? 'primary.light' : 'secondary.light', color: 'white' }}>
                <Typography variant="subtitle1" fontWeight="bold">
                  Select Substitute for Position {substitutingHomeTeam ? 
                    substitutingPosition + 1 : 
                    String.fromCharCode(65 + substitutingPosition)}
                </Typography>
                
                <FormControl fullWidth sx={{ mt: 1, bgcolor: 'white', borderRadius: 1 }}>
                  <InputLabel>Substitute Player</InputLabel>
                  <Select
                    value={selectedSubstitute}
                    onChange={(e) => setSelectedSubstitute(e.target.value)}
                    label="Substitute Player"
                  >
                    <MenuItem value="" disabled>Select a player</MenuItem>
                    {getSubstitutesForRound(
                      (showingSubstitutionDialog || 0) + 1, 
                      substitutingHomeTeam
                    ).map(playerId => (
                      <MenuItem key={playerId} value={playerId}>
                        {getPlayerName(playerId, substitutingHomeTeam)}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
                
                <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
                  <Button 
                    variant="outlined" 
                    color="inherit"
                    onClick={() => {
                      setSubstitutingPosition(null);
                      setSelectedSubstitute('');
                    }}
                    sx={{ mr: 1 }}
                  >
                    Cancel
                  </Button>
                  <Button 
                    variant="contained" 
                    color="inherit"
                    disabled={!selectedSubstitute}
                    onClick={() => {
                      if (substitutingPosition !== null && selectedSubstitute) {
                        handleConfirmSubstitution(
                          substitutingPosition, 
                          substitutingHomeTeam, 
                          selectedSubstitute
                        );
                        setSubstitutingPosition(null);
                        setSelectedSubstitute('');
                      }
                    }}
                  >
                    Confirm Substitution
                  </Button>
                </Box>
              </Paper>
            )}
          </DialogContent>
          
          <DialogActions sx={{ px: 3, py: 2 }}>
            <Button 
              variant="contained" 
              color="primary"
              onClick={() => setShowingSubstitutionDialog(null)}
            >
              Continue to Next Round
            </Button>
          </DialogActions>
        </Dialog>

        {/* Reset Match Confirmation Dialog */}
        <Dialog
          open={showResetConfirmation}
          onClose={() => setShowResetConfirmation(false)}
          aria-labelledby="reset-match-dialog-title"
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle id="reset-match-dialog-title" sx={{ bgcolor: 'error.main', color: 'white' }}>
            Reset Match Results
          </DialogTitle>
          <DialogContent sx={{ pt: 2 }}>
            <Alert severity="warning" sx={{ mb: 2 }}>
              <AlertTitle>Warning: This action cannot be undone</AlertTitle>
              <Typography variant="body2">
                Resetting the match will:
                <ul>
                  <li>Clear all frame results</li>
                  <li>Reset the round to 1</li>
                  <li>Keep the initial lineups intact</li>
                  <li>Remove all substitutions</li>
                </ul>
              </Typography>
            </Alert>
            <Typography>
              Are you sure you want to reset all match results?
            </Typography>
          </DialogContent>
          <DialogActions sx={{ px: 3, py: 2 }}>
            <Button onClick={() => setShowResetConfirmation(false)} color="inherit">
              Cancel
            </Button>
            <Button 
              onClick={handleResetMatch} 
              variant="contained" 
              color="error"
              disabled={loading}
              startIcon={loading ? <CircularProgress size={20} color="inherit" /> : null}
            >
              {loading ? 'Resetting...' : 'Reset Match'}
            </Button>
          </DialogActions>
        </Dialog>
      </Container>
  );
};

export default MatchScoring; 